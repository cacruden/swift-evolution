# Feature Enhancement: Demux Expression (aka Generalized Ternary)

* Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md)
* Author(s): [Paul Ossenbruggen](https://github.com/possen)
* Status: **Review**
* Review manager: TBD

## Introduction

The key advantage of the ternary operator is that is a very concise way of assigning a result from two expressions based upon a true-false control input. This proposal extends that notion to support more than two outcomes by allowing it to work with types other than just boolean and by pulling in some concepts from *switch* and *if*. This proposal adds powerful capabilities to that existing construct and tries to come up with something that is truly better than the venerable ternary operator by taking its best aspects and extending it. I beleive this fits well with the existing Swift language.        

Swift-evolution thread: [ternary operator ?: suggestion](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000810.html)

## Motivation

Currently, it is a not very easy to set a value as the result evaluating a switch using statements. Each case is a local scope which can't be used after the statement unless declared before the statement. Because of this, binding a variable or constant is not a single step process, and type inference can not be used to determine the type which is especially painful in Swift. This syntax streamlines that process of binding and inferring the type when you have an assignment that can change depending on the value of a switch statement, it also allows you to assign the result of one of many expressions based upon an input. It will reduce redundant code in each branch of the switch compared to the statement form. This proposal helps to unify the concepts of a switch expression and the ternary operator. The existing ternary only supports the *Bool* type as its selector, by supporting any enumerable type this proposal expands the possibilities for conditionally assigning multiple expressions to a result based upon a control input. In addition to these features, it improves some problems with the current ternary. Finally, container types for the input have the potential to add even more power to the demux operator. 

## Proposed solution

#### Background 

The ternary **?:** is an area of much debate because it is perceived as hard to understand for novices. I believe that as with anything it may be a little more difficult to understand at first, but it can be quite beneficial in many situations. We need to support both advanced as well as novice programmers. In addition, it has many benefits that can not be ignored when designing something that attempts to improve upon it. There are many concepts in Swift that take a little getting used to before they click, such as patterns in *switch* statements. 

Ternary benefits:
* It avoids large blocks of indented *if* or *switch* statements but it also allows you to indent if you prefer.
* Very concise format, essentially 2 characters. 
* Can be put into places where a statement could not, allowing a quick conversion to happen without the weight of a structured if statement. 
* Can select from two expressions on a single line. The else case always must be handled. There is no such guarantee in an *if* statement.
* Nests well (but best not to over use this). 
* Can't be confused with statement control flow. This can happen the *if..else* keywords are used. 
* Ensures that both sides of the result are of compatible type. 
* It is clear it only deals in expressions. 
* It is easy to tell that it will provide a result on each branch in a way that a statement never could. Statements are not obliged to return anything. 
* Most coming from C based languages are familiar with it. 

Downsides:
* Can't easily be searched on the web. (This proposal will remedy that). 
* Harder for novices to understand, but not insurmoutable. *if..then..else* is easier to understand for novices,. 
* Only supports two choices because it only takes a bool as the control parameter. (this proposal addresses that). 
* Sometimes hard to see where ternary begins and ends. Many put parenthesis around it to help with this. 
* The **:** in the ternary does not really look like it says else.  

Any change in this area must be not just be different but be better, there is precedent with the ternary operator that helps overcome the initial difficulty understanding it. A solution must have the following properties:

* Must be concise so it can be used where the current ternary is used.
* Must be appealing to more advanced users
* Must be fairly easy to understand for novices, hopefully easier to understand. 
* Must make sure that all routes through the expression produce the same base type. 
* Must allow setting a variable or constant to a value
* Must allow binding a name to a variable or constant.
* Must allow automatic type inference.
* Must support multiline format for improving clarity with more complex forms. 
* Must have a clear mental model. 
* Should be an expression like ternary is. 
* Should allow not just bool but any enumerable type. 
* Should allow more complex forms like switch and list like where an enum needs to convert to a string. 
* Should reduce the amount of code compared to the switch statement.
* Should be familiar as possible to notions that people already know.
* Should be searchable on the internet, currently ternary does not do this. 
* Should be usable anywhere an expression can be used. 
* Should have syntax that makes it clear that it is for expressions.
* Should look sort of like a function to emphasize it is an expression. 
* Should be usable where a quick conversion needs to be performed.
* Should not be massively different than the current ternary unless there is a good reason
* Would be good if it fixed some of the historical issues with the current ternary.
* Would be good if it provided the nice features of the switch statement such as pattern matching and where clauses. 
* It would be nice if it was not a really hard change that fundamentally changes everything about how Swift works. (like how making statements into expressions would be). 

I believe this proposal addresses all of these goals. 

#### Overview

First, I will say that ternary is not removed in this proposal, it will continue to exist but slightly modified. This is conceptually an extension of that notion. Since it is a breaking change, some other changes to improve on ternary make sense to introduce at this time.

The following is how you typically would write code to assign result from an enum using the *switch* statement, in this case a enum of three or more colors: 

``` swift 

  var result : Int 
  switch color { 
    case .Red: result = 0xFF0000
    case .Green: result = 0x00FF00
    case .Blue: result = 0x0000FF
    default: result = 0xFFFFFF
  }
  ```

Note that the type of result is not inferred, there is duplicated code assigning to result, it is quite a lot of code to write and for something this simple it fills multiple lines. It also may seem that you need to use *var* when *let* will work. 

With this proposal the repeated code is eliminated, it concisely allows assignment and uses type inference to determine the type and bind the name. It all fits easily on one line, if desired, but if it is clearer on multiple lines there is nothing that prevents that: 

``` swift 

  let result = ?(color, .Red: 0xFF0000 .Green: 0x00FF00 .Blue: 0x0000FF : 0xFFFFFF)
  
  ```
  
 even in the multiline format it is more concise and there is less clutter to deal with:
 
 ``` swift 

  let result = ?(color, 
  		.Red: 0xFF0000
  		.Green: 0x00FF00 
  		.Blue: 0x0000FF 
  		: 0xFFFFFF)
  ```

The parenthesis help to group the demux, it is a common complaint with the current ternary that it is hard to see. The syntax following the colon works the same as the existing *switch* so *where* and pattern matching work and it also supports a list of expressions. It is not far off from the existing ternary syntax and the switch statement so it will look familiar, and intuitive to those coming from other languages or even Swift. The use of parenthesis allow this to be used anywhere an existing ternary can be used. The parenthesis help to emphasize that this is an expression that will produce single result of the correct type.

Key points with this syntax:
* Very similar syntax to ternary. If someone comes across it and does not know what it means they can easily search for it on the web and find out what it is. Something that is not possible with the current ternary.  
* Utilizes the existing notions of the switch statement which is also intuitive. 
* Supports a list of expressions as an index into which choice to make (more on this later).
* Keeps the expressions and statements as separate concepts. To emphasize this, braces are for statements parenthesis are for expressions. Can be thought of as function like which fits well with expressions, becasue expressions can be thought of as functions. 
* The parenthesis are more in line with expressions as mathematical statements than say a brace or statement would be. There is one expected return value from the expression. 
* The question mark at the beginning of the parenthesis serves to immediately tell the developer this is a demux, something you can't necessarily know right away from a ternary. In a ternary you just see a floating conditional that does not stand out. Only when you get to the question mark and then the colon do you realize it is a ternary. 
* It is not more difficult to understand than the nil-coalesing operator or the existing ternary operator. I would say it is easier.
* The question mark works with the existing notion in Swift of the question mark meaning that something needs to be decided here. Like nil-coalescing operators and operator chaining. 
* It is clear when the beginning and end of the demux expression is. 
* Since there is more capability going in the expression for the *switch* form and list form, it is more important than ever that it be grouped with parenthesis. See the section in Alternatives Considered for the *->>** syntax that was attempted. It lacks structure. At the same time the ternary replacement form should not be significantly less terse. 
* The controller input is clearly separated from the choices using the already familiar colon. 
* The parenthesis formalizes the practice of putting them around the ternary for improved clarity.
* The parenthesis also help to keep it passable as a parameter to a function, as the commas are used to separate the list of choices. The commas may be optional in certain cases. 
* It is easily chained, the results of the previous call can be passed through to the next function. The parenthesis around the expression, make that clearer than it is with ternary. 
* It is easily nested, as is possible with the ternary, except with additional clarity, as each nest will have parenthesis around it. 
* *default:*, *then* or *else* are available for the *bool* form where one of the cases is not true. This can support a more English like flavor if that is a strong preference for developers. 
* Similar to the ternary it will short-circuit and only evaluate the expresion that is selected from the choices.

##### How this improves on ternary

In terms of readability, it improves on the ternary because I often find it hard to determine where a ternary begins, in unfamiliar code, looking at:

``` swift
x = x == y ? 49 : 3 
```
It is not until you get to the question mark that you realize it is a ternary and the x == y just is kind of floating there. The = and == just looks strange, should it be read a x = x first? Or is really saying x == y. Some developers add parenthesis to make it clearer, which is a good practice:

``` swift 
x = (x == y ? 49 : 3) 
``` 
With the new form parenthesis are built into it and are required. The parens emphasize that it behaves like a function:

``` swift
x = ?(x == y, 49 : 3) 
```

Alternatively the double-bang means opposite and this preserves the concise format for those who value that. The parens are similar to braces being required for *if* and *switch* statements. They help to emphasize the structure and avoids ambiguity as to how it should be read. The grouping in the ?() sequence should be interpreted as an expression.

``` swift 
x = ?(x == y, 49 : 3)  
``` 

Double bang is used to avoid conflict with the **not** operator with **!**. It will make it clear that this is different than **not**. The double !! can be thought of as **else**. The colon can be read as **then**. All of of these keywords are context sensitive so they could be used when it is not in **?()**. 

The **?(** makes it so it can't be confused with the statement form. Please see *Hybrid Approach* in **Alternatives Concidered** for a potential alternative with the caveat that it could more easily be confused with the statement form and is not nearly conise. 

##### Boolean Form
The examples above show *boolean* form.

##### Switch Form
The example above shows *switch* form. 

##### List Form
This proposal also supports a list form where you don't need to put the case labels in. A zero based index is used to select the expressions in the list following the **:**. 

``` swift 

  let result = ?(pickone, "A", "B", "C" : "Z")
  
  ```
This allows very concise way of picking among several expression choices.

#### Scalar Types

Some of enum selector type was shown in the **Overview**, I will continue a bit in some detail on enum, then cover other types of selectors.

##### (More) Enums 
As with *switch* you can specify, *default:* or if every case is covered, omit the default keyword.   

For example:

``` swift
  result = ?(color,  .Red: 0xFF0000 
  		     .Green: 0x00FF00 
  		     .Blue: 0x0000FF)  
```

One nice thing about this is that it follows the existing switch statement syntax, thus putting "case" in front of each is not necessary but can be done if desired. Like closure syntax not making you assign variables to every param, keeping things concise is very important for the most common uses of this expression. See *cases* below for one minor addition. 

##### Boolean 

For booleans it is a very similar form. For example the new format:

``` swift 
result = ?(lightState, "Blink" : "Solid")
```

compared to the current ternary form:

``` swift
result = lightState ? "Blink" : "Solid"
```

The use of *!!* fixes the problem with the ternary, that the *:* does not mean take the opposite action. *!!* helps to say **else**

One advantage of this format is that the parenthesis help group the ternary which is one complaint with the original ternary operators. One downside is this is a breaking change and it slightly deviates from C but I think it is important for consistency and the other advantages present in this proposal.

This format is supported by the list format, if one wanted to you could use the list for conciceness, form here but above is preferred. Of note, one might think that for a boolean false is first in the list but in this true is first because that is most compatible and natural with the existing ternary.

```swift 
result = ?(lightState : "Blink", "Solid")
```

These forms are also supported for consistency:

```swift
result = ?(lightState : true: "Blink",  false: "Solid")
```

Thus allowing this as well if you wanted to reverse the logic without using the ! operator:

```swift
result = ?(lightState : false: "Blink", true: "Solid")
```

##### Ranges

For ranges:

``` swift 
  warning = ?(intensity,  0...30: "Nothing to Worry About"
                          31...50: "Maybe something to worry about"
                          51...70: "Better start panicking"
                          71...100: "Run for your lives!"
                          : "Not telling" )
```

In addition to supporting enums and ranges, any enumerable type is supported with these forms. So for an integer you could do something like this where each value maps to a specific outcome, the nth element maps to the integer.

##### Integers

``` swift 
  character = ?(charNum, "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K" : "Z")
```

Note that for something like an integer *default:* would be required because that is too many to cover every value of int.

##### Float 

Float could only be supported with ranges.

##### Tuples

Tuples are supported exactly as they are in the statement form. 

#### Container Type and Composability

This could be applied the functional map and other functions.

For example, this would compose nicely with map:

```swift
["bear", "in", "the", "woods"].map(?($0,
	"bear":		"fish" 
	"in":		"out"
	"woods":	"water" 
	_:			$0)
)
                                              
```

```swift
["fish", "out", "the", "water"]
```

> **The part in this sidebar is not officially part of the proposal, I put in because it may be interesting to directly allow applying a ternary on container types, but that is probably something that is best not tackled for this first proposal. This might be useful as a future direction. It may also be the case that the functional commands do everything needed for container types and this would only serve to confuse matters. I welcome further discussion on this half baked idea. I put this in there to show that these ideas could go even further if we decide it is a good direction. **: 

> In this case you are might have a dictionary that does not have the information that you want, this could allow allow you map it. At this point it is hard to say how this would be different than using *map*.  

> ``` swift
> [.North: "North", .South: "South", .East: "East", .West: "West", .Stay: "Stay"] ?(		
	.North: ( 0, -1) 
 	.South: ( 0,  1)
	.East:  (-1,  0)
	.West:  ( 1,  0)
	_: 		( 0,  0))
> ``` 

> One area of improvement to figure out. is to be able to switch on the value or key. I am open to suggestions on how to best accomplish that. A tuple seems natural, but not sure how to make it the switch value. 

#### Tuple List (To Do)	

It seems like a list of Tuples could also be interesting but need to figure out what that would look like, and how you would determine which part of the tuple is going to be the control expression. 

#### Result Types

All expressions must match the result type and for type inference to determine the type, expressions must be the same result type. If you want something else it will not automatically find a more generic type, for example this would generate an error: 

``` swift
  let result = ?(value, 
  	1: "String"
  	2: 52 
  	: nil)
```

will not automatically create an Any? for "result". They must specify the more generic type on the left hand side. 

``` swift
    let result : Any? = ?(value,
    		1: "String"
    		2: 52 
    		: nil)
```

### Conclusion 

This proposal has quite a few advantages it addresses not already mentioned above: 
* Now you can search *?(* in a search engine and get results back where the old ternary you would not be able to find anything. 
* Compact syntax only adds 3 characters to the 2 character ternary (5). 
* *fallthrough* and *break* statements can't cause confusion because each result is an expression it can only do one thing and return. If you need that kind of control the statement form is still available. 
* This should have real benefits to functional programmers where imperative approaches are not as desirable. This proposal furthers that capability.  
* Easier to follow than the existing ternary, no floating conditional before you get to the **?** and **:**. 
* Fits very nicely with Swift's existing constructs to solve some problems that are currently cumbersome such as type inference. Almost every example in the Swift Language Book's section on statements could be more simply written with this approach. 

I think this the best balance of familiarity, compactness, power that can be achieved. 

> One further note to think about but not part of this proposal, if we have a demux expression is there value in a mux expression which does the opposite which maps one value to multiple outputs based upon a control?

> something like 

> ``` swift
?(source : control-expr : destination1, destination2, destination3, default:destination)
```

> where destinations are variables. Might be very useful with generators. 

## Detailed design
TODO: needs work!
### Grammar:

The grammar needs to determine the difference between the two forms, switch and array forms, the colon and the cases make that clear it is a switch like expression and the comma separate list keeps the elements separate. 

#### Boolean Form:

``` swift
result = ?(control-expression, expression-if-true : expression-if-false)  
```

#### Switch Form:

``` swift
  result = ?(control-expression, pattern 
  	case*opt* label1: expression1, 
  	     label2: expression2,
  	     ...
  	     labelN: expressionN, 
  	default*opt*: expression)  
```

#### List Form: 

``` swift
  result = ?(index-expression, expression1, ... expressionN, default*opt*:expression )  
```
A demux expression allows certain different expressions to be executed depending on the value of a control expression.

#### Grammar 
A demux expression has the following form:

```
 ?( control-expression, 
    case pattern 1: expression1, 
           pattern 2 where condition: expression,
    case pattern 3 where condition: expression,
           pattern 4 where condition: expression,
    default:
           expression
  )
```

Only newly defined grammars are presented here. See Swift switch statement grammar for the existing grammars: 

```
switch-expression → ?(expression, switch-expression-cases)

switch-expression-cases switch-expression-case switch-expression-cases

switch-expression-case case-label expression | default-label expression
```

demux expression results must be a compatible type of the result. 

### Pattern Matching: 

All the current pattern matching abilities of switch statements should be present for example. "where" clauses. 

## Impact on existing code

The existing ternary will need to be transformed into the new format. The converter tool will need to make that change. I could have continued to allow the original form, in fact, that was my intention when I started this proposal, but for consistency it is important to make a breaking change. I think the benefits of this approach warrant a breaking change. It is not different just to be different but to unify some concepts and provide powerful new capabilities.  

## Alternatives considered

Much of these questions are based upon feedback from the Swift-Evolution mailing list in the thread mentioned above. 

### Why not extend existing statements to be usable as expressions?

In a statement block it is common to not have return values. So you could make it an expression if the return value is used. This makes it more complex from both the programming model and the compiler perspective. This is what other languages do such as Haskell. 

 With *if* statements being used as expressions not all parts need to be handled in a if statement:

``` swift
if cond {

}
```

The *else* part can be left off. If *if* statements made into an expression suddenly just by assigning the result the *else* part will be required, unless you make the result an optional. So adding *x = *: 

``` swift 
x = if cond {

}
```
will then create an error because the *else* part is required. Otherwise you could make it an optional, but then making it an optional just pushes the conditional logic further down elsewhere in the code because it must be unwrapped later. One last possibilty, which probably would never be accepted, is that all statements must have an *else* clause. 

All these points serve to illustrate that statements and expressons should be kept separate concepts as they currently are in Swift. Expressions are always going to return a value and statements don't. 

Another problem is the proliferation of braces, expressions should be light, it looks cumbersome to have braces all through your expressions. It does not look as clean having braces in an expression as braces are usually used to group blocks of statements. Further, it will help reinforce the difference between an expression and a statement to only use braces for statements. For example, all the extra braces in this case are harder to read:

``` swift
let color = switch enumColor {
  case .Red: (switch shade {case .DarkRed: 0xFFEEEE
                            case .LightRed:0xFF0000
                            default: 0xFF1010 } )
  default: 0xFFFFFF
}
```

note that the commas for each case are not necessary with this example but does look significantly more like Lisp :-)

If you look at the language grammar there is a clear separation between what is an expression vs a statement. It would be too large a change to try to unify expressions and statements. See thread for examples. 

Finally, switch statements can have multiple statements after them, that is not the case for expressions, only one sub-expression can be in each part of the case. There is ambiguity as to the return value if this was a statement: 


``` swift
let color = switch enumColor {
  case .Red: (switch shade {case .Dark: func1() 
                                  x = 15 
                                  40 
                            case .Light: func3() 
                                  13
                                  x = 10
                            default: func2()
                            } )
  default: 0xFFFFFF
}
```

This proposal is likely far more straightforward to add to the existing language than making statements into expressions. 

Having statements that act as expressions encourages code that has side effects, which goes against one of the core concepts of functional programming. If I am working on a team, and someone wants to add some new feature and they see a big indented “if” with braces, they will just stick it in there and ignore that it is a functional approach. That new statement they add may add a bunch of side effects and add bugs to the code. If it is an expression that temptation will be less likely. They will see that this code is intended to work as an expression and won’t be able to just stick another statement with a bunch of side effects into it. 





### Isn't this just about doing stuff on one line?

My proposal is about making expressions into first class citizens in terms of control flow. Its main purpose is definitely not about doing things on one line, that is just a side benefit if it works for your particular situation. This proposal supports and encourages multiline formatting and I think actually makes things cleaner and clearer than the statement forms. Quick and easy things things should remain quick and expressable concicely. 

This proposal does often make signifiant reductions in the amout of code written vs a statement. See prior examples.

### I thought we were trying to get rid of ternary!

I went down this path and even wrote two draft proposals one for *if..then..else* one for *switch* expressions, I tried using my proposal and found it was much harder to use, and did not really help with readability as was hoped. Here are some of the reasons: 

* You could not simply put it in a function argument, the way you can with the ternary operator. 
* It muddies the concepts of statements and expressions. The programming model would fundamentally change. 
* It ignored the many benefits of ternary. 
* The *if...then...else*  got lost in in the keywords. 
* Using *if* and *switch* implies formatting that we really don't want in an expression context. 
* Simple one liners are not possible
* It went from 2 to 10 characters, much more typing. 
* Readability was not much better, the operators pop out much better in source.
* It created a problem where it was confusing that for the statement form  if cond { } else { } might require *then* if cond then {} else {}. Do we make *then* optional for statements? It does not fit with the existing swift model where the brace comes immediately after the conditional.  
* Keywords imply indenting which rules out quick single liners.
* I was pretty sure it would be rejected by the community because it was different but not necessarily better than the ternary operator, I believe this proposal is better than the existing ternary, due to the support for multiple types and more flexibility.  

### Why not use *switch* or *if* keyword that returns a value?

Went down this path and touched on it in the previous answer. This looks strange to me:

``` swift
let val = if contr { X } else { Y } 
```

this is essentially a statement which argues it should be formatted like this and which is not compact:

``` swift
let val = if contr {
  X 
} else { 
  Y 
} 
```
Plus if and switch have an equal to their left, pretty non intuitive. Look at all those braces!

### Why not use some other keyword where you can control formatting?

I tried this with *pick*...*from* The idea is that by introducing new keywords the format had no preconceived notions. 

In addition to the community response being non existent, it does not fit the compactness goals:

```swift

let x = pick cond from 4, 8

```

It did feel like it was kinda on the right track to me. So I kept going.

### How about some new operator, lets call it the *Selector Operator* like ->>? 

This also does not have the preconceived notions and we can control how it looks. Boy, I really thought I had it now! 

``` swift
let a = sel ->> .Red: 1, .Green: 2, .Blue: 3 
let b = sel ->> .Red: 1, .Green: 2, .Blue: 3, default: 4
let c = sel ->> case .Red: 1, case .Green: 2, case .Blue: 3, default: 4
let d = sel ->> .Red: 1, (sel ->> .Sun: .Yellow, .Moon: .White, .Stars: .Twinkle), .Green: 2, .Blue: 3, default: 4
let e = sel ->> cases: .Red: 1, case .Green: 2, case .Blue: 3, default: 4
```

But looking at this it kind of lacks structure, it is kind of hard to tell where the ternary is. 

> This specific proposal has another problem.  Since you’re using “,” you’ve introduced grammar problems. For example, you wouldn’t be able to use this operator in a function argument list or array literal, because the , would be parsed as part of the argument list separator.

> <cite>-- Chris Lattner</cite>

> I would characterize this as “different” than ?:, but not better.  Given that it isn’t “better”, I’d argue that following C (and tons of other languages) would make sense here.

> <cite>-- Chris Lattner</cite>

### Keyword, Hybrid and Operator Approach

Hybrid approach, function like name for *if, else, select*, uses : to separate selector, and else to handle differences
``` swift
let x = if(x == y : true else false) 

let x = switch(choose : case A: "A",
			case B: "B",
			case C: "C")
			
let y = select(choose : "A", "B", "C", default:"D")
```

full keyword:

``` swift
let x = if(x == y then true else false) 

let x = switch(choose then case A: "A",
			   case B: "B",
			   case C: "C")
			
let y = select(choose then "A", "B", "C", default:"D")
```
and these are some variants, that I explored which use more keywords.

``` swift

let y = switch(choose from 	case A: "A",
				case B: "B",
				case C: "D")

let z = select(index from "A", "B", "C")
```

This does have some benefits and is worth considering as an alternative if **?(** seems too terse. The advantage of this is that it looks more like a function, which is what an expression really is. The different forms would also allow different syntaxes and would potentially be easier to parse. I think that the **?(** appreach might be applicable to more types which is why I went with that proposal first. 

Advantages:
* Easily read from novices
* Keeps the forms separate for bool, list vs switch forms. Which may be less confusing. 
* Has function like expressions
* Is function like for easy chaining.

These approaches while more easily read:
* Are not nearly as concise as the ternary operator
* The **?(** can not be confused with *if*, *switch* it is its own thing. 
* Get lost in the words but not too bad. 
* One thing that Swift nicely solved is the *if* running up against the parenthesis one thing that really bothers me. This would codify it. Although in this case it would actually make sense, where it did not in the statement form. 
* There would need to be multiple variants for *if*, *switch* and *select*. 

Or if making the difference more obvious we could combine the forms. 

```swift 
if? (x==y : true, false)
switch? (control : .North:”N”, .South:”S”, .East:”E”, .West:”W”, default:” “) 
select? (control : “A”, “B”, “C”, default:”D”) 
```

I expect that that may be more controversial though. As it then steps into the optionals area. 

### Why not put the conditional outside the braces?

``` swift
let result = x == y ?("A", else "B")
``` 
There is some appeal to this and it was suggested by Charles Constant. I did not go with this for the following reasons:

* Chris Lattner said it was different but not better.
* The same problem with ternary where the conditional is floating out before the demux expression makes it so you don't realize you are dealing with a demux until you reach the *?(*. 
* The x == y part looks like you can just stop reading there. But you need to keep going. Putting it inside, you know that it is for the demux operator. 

### Why not use Python's if..then..else syntax?

In Python you put the conditional in the middle and the first true is handled first then the else part is handled last. 
``` swift
x = "A" if x < y then "B" 
```

This has the advantage of the type of the first thing is immediately after the assignemnt and it reads well as an English statement, I think it has the following problems, it is confusing:

* The choices should be at the end
* Similar to the ternary, it is not until after you get to the if that you can tell that it is a conditional. 
* When I first saw this added to Python I found it confusing and not intuitive to any other programming languages. 
* It is quite long.
* It does not support the switch forms easily, but there probably is a way to make it work.
* It adds a non contextual reserved word **then** which others have pointed out is used quite frequently for certain kinds of programming.
* I don't think it fits with Swift's existing syntax patterns that well and it is certainly very different than anything in C.
* It can be confused with the statement form of *if..then..else*

Requiring parenthesis would help with the second point:

``` swift
x = ("A" if x < y then "B")
```

### Isn't this going to be abused like ternary already is?

I don't think ternary is abused. It can easilty be used, like anything, to make something complex. Developers should use the tool that best fits the situation. A well placed ternary can avoid a lot of things that detract from the main point of a function. Quick type conversions don't need to span multiple lines. Being able to express something without the need for large indented blocks is a huge win. With this you also know that all cases possible will get you a result, there is no guarantee in an *if* statement. 

## Community Feedback

There have been many contributors to this discussion that I would like to thank, but not in any particular order: Al Skipp, J. Cheyo Jimmenez, Andrey Tarantsov, Marc Kraup, Jakob Egger, Taras Zarkharko, Thorsten Seitz, Alex Law, Matthew Johnson, Rudolf Adamkovic, Kevin Ballard, Kevin Lundberg, Andrew Brown, Craig Cruden, Dennis Lysenko, Jordan Rose, Brent Royal-Gordon, Vester Gottfried, Chris Lattner, Charles Constant, Austin Zheng, David Owens II, Jakob Bandes-Storch, Conrad Kutsch, David Abrahams. 

Please see the full thread to see their contributions.

In the general conversation about whether ternary can be replaced with a keyword statement Chris Lattner said: 

>* No, I’m not aware of anything that I’d consider to be better than ?:

> In brief, and just MHO, but:

> - I agree that ?: is ugly and magic, and is an additional thing people have to learn if coming to swift without encountering a C family language.
> - I agree that it is unfortunate that it uses “?” in particular, since we’d prefer that to be associated with optionals.

> The closest proposal I’ve seen is the “if cond then value1 else value2” syntax, however that has serious (IMO) problems:
> - It is substantially more verbose than ?:, so much so that it obscures the logic that was trying to be captured.  Simple > things like this become swallowed in syntax:
>  let x = cond ? 4 : 8
>  let x = if cond then 4 else 8

> - Because it looks like an if statement, people will end up writing it like:

> let x = if cond then
>		some_long_expression
>	   else
>		some_other_long_expression

> When this happens, we now have new problems: 
> - At a glance, it “looks” like an if statement, but it is semantically different.
> - it only accepts expressions, not statements.  The way it is flowed makes it look like a statement.
> - It is now force indenting a lot, which just looks weird and isn’t precedented in Swift.

> On this thread, people have been focusing on the negative parts of ?: without considering the positive aspects of it.  Here are some of the positive aspects of it:

> - It is extremely concise, and covers a very common pattern.
> - It is pervasively standardized in a very wide range of languages.
> - It’s weird syntax reduces the odds that people would flow it out and use very large expressions in it.
> - It chains well for multiple conditions because of its associativity.

> To repeat what I said upthread, to build a compelling case that we should replace ?:, its replacement should be *better* than ?:.

> Believe it or not, we only change things when there are strong reasons, and in the absence of any other strong reason, being similar to the C family is a benefit, not a problem.

> <cite>-- Chris Lattner</cite> 

I have done my best to address as many of these issues as possible, with I believe, a lot of success, however every solution has some compromises these are the ones not addressed with this proposal:

* It deviates from C standard a little
* It is still uses the ternary ? but I believe slightly better due to grouping. 
* We use **?** which Chris mentioned as liking to keep it for optionals. However, we use **!** for *not* even though that is also used for optionals. 
* It still uses question mark which, I am not sure can be avoided, but maybe that is ok as Austin Zheng said: 

When discussing the notion that **?** is only for Optionals Austin Zheng expressed this opinion: 

> In terms of semantics: The argument was made earlier that "?" is associated closely with optionals and not suitable for this purpose; I disagree: "?"'s overarching meaning is that of uncertainty or querying, which makes sense both in terms of control flow (predicate determines which way to go), as well as optionals (whose 'empty or not' status is unknown until explicitly checked for, e.g. via if-let).

> <cite> -- Austin Zheng </cite>

In responding, I said: 

> Again when looking at the nil-coalescing operator, implicit unwrapping (!) and optional chaining, I agree. It seems that the ternary operator fits quite nicely with ? meaning this is a question and that notion is encoded repeated thorough the Swift language. ? is almost a key concept in the language and making it keywords takes away from that and it seems even more wise to keep as is because it was a good design from the start. I also see why Chris and others haven’t really wanted to get into this discussion, but wisely let it happen so we could come to the same conclusion. It is almost as if ? and ! are the core concepts of the language for new Swift learners. 

Another exercise was to take a complex nested ternary expression, Paul Ossenbruggen wrote:

> Agreed, I was thinking to I really want turn something that was 2 characters into 10 and will I really be happy with that at the end of the day. A properly formatted ternary can be quite easy to read, it is when people get sloppy and try to cram too much into one expression that they get really hard to follow. For example,

> ``` swift
>     return (a<b) ? (b<c) ? b : (a<c) ? c : a : (a<c) ? a : (b<c) ? c : b;
> ``` 

> If formatted like this becomes easier follow the logic (at least to me):

>``` swift
> return a < b
>	 ? b < c 
>	    ? b 
>           : a < c 
>	          ? c 
>	          : a 
>	  : a < c 
>	     ? a 
>	     : b < c  
>              ? c 
>	       : b
	```

> Is this new syntax helping?
 
>``` swift
>    return if a < b 
>	           then if b < c  
>	                then b 
>                  else if a < c 
>	              then c 
>	              else a 
>	    else if a < c 
>	         then a 
>	         else if b < c  
>                     then c 
>	              else b
>```

> I found this translation quite tricky to do. maybe parens help?
> ``` swift 
>     return (if a < b 
>	            then (if b < c  
>	                 then b 
>                  else (if a < c 
>	                      then c 
>	                      else a))
>	            else (if a < c 
>	                  then a 
>	                  else (if b < c  
>                       then c 
>	                      else b)))
```

> Not really, and I still I found this hugely frustrating, so much so that I am going to drop all support for this proposal and remove my name from it. If anyone wants to take over feel free. 

> Others still keen on the idea should try this experiment. It convinced me is horrible idea :-) I don’t want to be blamed for it by every Swift programmer in the future. 

Responding to the switch expression proposal which this proposal combines Charles Constant said: 

> At the moment, the alternatives are, what, using a dict to map values? trying to shoehorn a corresponding set of values into an enum? using the existing switch statement (pretty verbose in Swift, due to "let" scope etc)? In my own Swift code, I have encountered situations, frequently, where I wished I had an equivalent to a ternary condition that handled more than two values. Chaining multiple ternary conditions together is unreadable. This proposed Switch assignment expression would take care of that. 

> Definitely has my vote!

> <cite>-- Charles Constant</cite>

When discussing the replacement of ternary operator Chris Lattner said: 

> To be clear, I’m not completely opposed to a change here, but it has been discussed extensively before, and didn’t turn up any good ideas either.  That doesn’t mean that a good idea isn’t out there - it might be a very hard problem (of course, it really might be that ?: cannot be beat just because it is established, and anything as good as it but different would be considered “weird and not better”).

> <cite>-- Chris Lattner</cite> 

I think my proposal improves ternary, not hard to understand, and provides a needed abilty. 

In response to the *if..then...else* expression proposal, not this proposal, Austin said this: 

> I am strongly against this proposal.

> In terms of clarity: Paul Cantrill made the very good point in a different thread that "beginner-friendly" syntax may not be the same as syntax optimized for the productivity of developers working on serious projects. I think this is a great example of that principle in action. Sigils stand out to the eye when scanning code in a way that keywords don't, even in an IDE with syntax highlighting (and the perils of relying upon relying upon color have been discussed pretty thoroughly in the mandatory 'self' thread). Replacing them with keywords makes it harder to delineate the arguments.

> In terms of semantics: The argument was made earlier that "?" is associated closely with optionals and not suitable for this purpose; I disagree: "?"'s overarching meaning is that of uncertainty or querying, which makes sense both in terms of control flow (predicate determines which way to go), as well as optionals (whose 'empty or not' status is unknown until explicitly checked for, e.g. via if-let).
> 
> <cite> -- Austin Zheng</cite>

This is another possibilty which I think could work but it is not as general as this proposal, this works mostly with bool:
> What do you think about this?

> let i = if(x == y, 123, 456)

> the second parameter could be optional, so if the condition is false you would get a nil

> let i = if(x == y, 123) // may return nil

> making it function like would make a bit more natural to chain other functions

> let i = if(x == y, 123).map( ... )

> I am usually not an opponent of the ternary conditional operator, but I do know instances where beginner were struggling with it, when they first encountered it. That you cannot google it makes it worse. And in Swift the question mark has a special meaning regarding optionals, that other languages don't have.

> This is just an quick idea though. I agree with Chris, that we should only replace it, when we are really sure the new solution is better.

> -- <cite>Vestor Godfried</cite>

See the **Alternatives Considered** section for discussion of this approach. 

> It is a way to put 'switch' into an expression. I'm not a fan of the two different colons, but that's "just" syntax.

> -- <cite> Jordan Rose</cite>

The double colon is a little strange. I am open to suggestions on better separators. I was trying to keep it as much like the existing ternary as possible but you could do something like *--* or *->*. I wouldn't want that to prevent the proposal from being accepted. I know smaller things are important. The bar could be used instead of the colon.  

> I think this is a good point. We definitely want to keep the boolean ternary operator compact for the simple cases, and that may be at odds with a general switch expression (with multi-case pattern match).

> -- <cite> Jordan Rose</cite>

This caused me to revisit the **:** meaning the else part and changed it to !!. This supports compact ternary like expression for simple caseas and swtich expressions in the more complex cases. 

> In the case where your input is hashable, you could just do:

> let i = [.Red:0xff0000, .Green:0x00ff00, .Blue:0x0000ff][color]

> this would mean that color must be a Color and not an Optional<Color> (because of swift 2.x limitations)

> -DW

This is an interesting possiblility and it is nice in that it utilizes the Dictonary and Array which are a nice intersection of possiblities. However, the big downside is that pattern matching would not be possible and it is a bit more esoteric. 


