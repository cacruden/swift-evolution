# Generalized Ternary

* Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md)
* Author(s): [Swift Developer](https://github.com/swiftdev)
* Status: **Review**
* Review manager: TBD

## Introduction

The key advantage of the ternary operator is that is a very concise way of picking a result from two expressions. This proposal extends that to support more than two and allowing that to work with types other than just boolean by pulling in some concepts from *switch* and *if*. This proposal adds powerful capabilities to that existing construct.       

Swift-evolution thread: [ternary operator ?: suggestion ](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000810.html)

## Motivation

Currently, it is a not very easy to set a value as the result evaluting a switch using statements each case is a local scope which can't be used unless declared before statement. Because of this binding a variable or constant is not a single step process and type inference can not be used to determine the type. This syntax streamlines that process when you have a variable that can change depending on the value of a switch statement. It should also reduce redundant code in each branch of the switch compared to the statement form. 

Second the existing ternary only supports one type as it selector. This allows any enumerable type. 

## Proposed solution

#### Background

Please see **Alternatives Considered** section before rejecting this as making Ternary worse. 

#### Overview 

The ternary "?:" is an area of much debate because it is perceived as hard to understand for novices. I believe that as with anything it may be a little hard to understand at first it can be quite benefitial in many situations. Avoiding large blocks of indented *if* or *switch* statments is one of the best benefits of the ternary operator but it also allows you to indent if you prefer. 

Other benefits:
* Very concise format.
* Pops out from text in a way that keywords do not.
* Can be put into places where a statement could not
* Can select from two expressions on a single line.
* Nests well (but good programmers would be best to not over use this though). 
* Ensures that both sides of the result are of compatible type. 
* Most coming from C based languages are familiar with it. 

Downsides:
* Can't easily be searched on the web. (This proposal will remedy that). 
* Harder for novices

First, I will say that ternary is not removed in this proposal, it will continue to exist as it does today. This is conceptually an extension of that notion.  

This should have real benefits to functional programmers where imperative approaches are not as desirable. This proposal furthers that capability.  

The following is how you typically would write code to assign result from an enum using the *switch* statement, in this case a enum of three or more colors: 

``` swift 

  var result : Int 
  switch color { 
    case .Red: result = 0xFF0000
    case .Green: result = 0x00FF00
    case .Blue: result = 0x0000FF
    default: result = 0xFFFFFF
  }
  ```

Note that the type of result is not inferred, there is duplicated code assigning to result, it is quite a lot of code to write and for something this simple it fills mulitple lines. It also may seem that you need to use *var* when *let* will work. 

With this proposal the repeated code is eliminated, it concisely allows assignement and use type inference to bind to determine the type and bind the name. 

``` swift 

  let result = ?(color : .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x0000FF, default: 0xFFFFFF)
  
  ```

The use of parenthesis instead of braces helps to further distingush it from a statement. The syntax following the colon works the same as the existing switch so *where* and pattern matching work. It also is not far off from the existing ternary syntax and the switch statement so it will look familiar and intuitive to those coming from other languages or even swift. The use of parenthesis allow this to be used anywhere an existing ternary can be used. 

#### Selector Types Detail

So shown in the **Overview** is the enum case now, I will continue a bit in some detail on enum, then cover other types of selectors.

##### Enums 
So as with *switch* you can specify, *default* or if every case is covered, omit the default keyword.   

```
If all case in the enum are covered the "default:" keyword can be omitted. 

For example:

``` swift
  result = ?(color : .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x0000FF)  
```

One nice thing about this is that it follows the existing switch statement syntax, thus putting "case" in front of each is not necessary but can be done if desired. Like closure syntax not making you assign variables to every param, keeping things concise is very important. 

##### Ranges

For ranges:

``` swift 
  warning = ?(intensity : case 0...30: "Nothing to Worry About",
                          case 31...50: "Maybe somthing to worry about", 
                          case 51...70: "Better start panicking", 
                          case 71...100: "Run for your lives!"
                          default: "Not telling" )
```

In addition to supporting enums and ranges, any enumerable type is supported with these forms. So for an integer you could do something like this where each value maps to a specific outcome, the nth element maps to the integer.

###### Integers

``` swift 
  character = ?(charNum : "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", default:"Z")
```

Note that for something like an integer *default:* would be required because that is too many to cover every value of int.

##### Arrays 

##### Dictionaries

#### Result Types

All expressions must match the result type and for type inference to determine the type, expressions must be the same result type. If you want something else it will not automatically find a more generic type, for example this would generate an error: 

``` swift
  let result = ?(value ? 1: "String", 2: 52, default:  nil)
```

will not automatically create an Any? for "result". They must specify the more generic type on the left hand side. 

``` swift
    let result : Any? = ?(value ? 1: "String", 2: 52, default:  nil)
```

## Detailed design

### Grammar:

``` swift
  result = ?(control-expression : pattern case label1: expression1, label2: expression2, ... labelN: expressionN, default: expressionD)  
```

``` swift
  result = ?(enumerable-expression : [expression], default:expression )  
```
A expression allows certain different expressions to be executed depending on the value of a control expression.

A expression has the following form:

```
 ?( control-expression : 
    case pattern 1: expression1, 
           pattern 2 where condition: expression,
    case  pattern 3 where condition: expression,
           pattern 4 where condition: expression,
    default:
           expression
  )
```

Only newly defined grammars are presented here. See Swift switch statement grammar for the existing grammars: 

```
switch-expression â†’ switch expression switch-expression-cases

switch-expression-cases switch-expression-case switch-expression-cases

switch-expression-case case-label expression | default-label expression
```

"switch" expression results must be a compatible type of the result. 

### Pattern Matching for "switch": 

All the current pattern matching abilities of switch statments should be present for example. "where" clauses. 

## Impact on existing code

Since this is a new capability and nothing else is being changed there should be no impact on existing code.  

## Alternatives considered

### Why not extend existing statements to be usable as expressions?

In a statement block it is common to not have return values. So you could make it an expression if the return value is used. This makes it more complex from both the programming model and the compiler perspective. 

Another problem is the proliferation of braces, expressions should be light, it looks cumbersome to have braces all through your expressions. It does not look as clean having braces in an expression as braces are usually used to group blocks of staements. Further it will help express the difference between an expression and a statement to only use braces for statements. For example all the extra braces in this case are harder to read:

``` swift
let color = switch enumColor {
  case .Red: (switch shade {case .DarkRed: 0xFFEEEE
                            case .LightRed:0xFF0000
                            default: 0xFF1010 } )
  default: 0xFFFFFF
}
```

note that the commas for each case are not necessary with this example but does look significanly more like Lisp :-)

If you look at the language grammar there is a clear separation between what is an expression vs a statement. It would be too large a change to try to unifiy expressions and statements. See thread for examples. 

Finally switch statements can have multiple statements after them, that is not the case for expressions, only one sub-expression can be in each part of the case. There is ambiguity as to the return value if this was a statement: 


``` swift
let color = switch enumColor {
  case .Red: (switch shade {case .Dark: func1() 
                                  x = 15 
                                  40 
                            case .Light: func3() 
                                  13
                                  x = 10
                            default: func2()
                            } )
  default: 0xFFFFFF
}
```

If changing statements into expressions is what is decided, then this seems like a far bigger change and beyond the scope of this proposal and this proposal should be declined. This proposal is likely far more straightforward to add to the existing language than making statements into expressions. 

### Add a new keyword "cases"?

you could make a "cases" keyword that is interchangeable with "case" to help readablity: 

``` swift
  int result = switch colorEnum { 
    cases      .Red: 0xFF0000,
               .Green: 0x00FF00,
               .Blue: 0x0000FF,
    default:   0xFFFFFF
  }
```
best not to add new keywords unless necessary, if people think this would help readablity, it should be an easy addtion. Would probably also want to support in statements. 
