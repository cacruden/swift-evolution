# Generalized Ternary

* Proposal: [SE-NNNN](https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md)
* Author(s): [Swift Developer](https://github.com/swiftdev)
* Status: **Review**
* Review manager: TBD

## Introduction

The key advantage of the ternary operator is that is a very concise way of picking a result from two expressions. This proposal extends that to support more than two and a way of allowing that to work with other types than just boolean.      

Swift-evolution thread: [ternary operator ?: suggestion ](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000810.html)

## Motivation

Currently, it is a not very easy to set a value as the result evaluting a switch using statements each case is a local scope which can't be used unless declared before statement. Because of this binding a variable or constant is not a single step process and type inference can not be used to determine the type. This syntax streamlines that process when you have a variable that can change depending on the value of a switch statement. It should also reduce redundant code in each branch of the switch compared to the statement form. 

## Proposed solution

#### Background:

Statement blocks, that is code surrounded by braces, can consist of multiple lines of statements where expressions can not, these statements may or may not return a result of the same type that can be assigned to one result value. Trying to make the existing statements into expressions will add complexity, clutter, harder to implement and will be confusing to users. Please see **Alternatives Considered** section before rejecting this as making Ternary worse. 

#### Overview 

The Ternary is an area of much debate because it is perceived as hard to understand for novices. I belive that as with anything it may be a little hard to understand at first it can be quite benefitial in many situations. Avoiding large blocks of indented "if" or "switch" statments is one of the best benefits of the ternary operator. Other benefits:



First I will say that ternary is not removed in this proposal, it will continue to exist as it does today. Ternary is very powerful and a consise way of getting the result of two epressions.  

Functional programming also enjoys very concise ways of performing operations on flows of data. This proposal furthers that capability.  

The idea is to keep existing model for switch as much as possible using the existing constructs both make the implementation simpler and hopefully consistent with the way switch currently works. The main change here is that each part is an expression instead of statement(s) otherwise it is the same old switch but usable where you would have expressions.  In today's swift if you want to bind and initalize a variable based upon a enum value, you would write something like this:

``` swift 

  var result : Int 
  switch color { 
    case .Red: result = 0xFF0000
    case .Green: result = 0x00FF00
    case .Blue: result = 0x0000FF
    default: result = 0xFFFFFF
  }
  ```

With this proposal much of the repeated code could be eliminated and the result will automatically bind the var.

``` swift 

  var result = ?(color : .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x0000FF, default: 0xFFFFFF)
  
  ```

The lack of braces helps to further distingush it from a statement. Also, the use of a single case separated by commas is possible with the current swift statement. 

The switch keyword can be used where you would have expressions: 

``` swift
  result = switch pattern case label1: expression1, label2: expression2, ... labelN: expressionN, default: expressionD  
```
If all case in the enum are covered the "default:" keyword can be omitted. 

For example:

``` swift
  color = switch colorEnum case .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x0000FF  
```

Note that any of these expressions can be surrounded by parenthesis to make clear that the expression returns a value but it is not required. 

``` swift
  let color = (switch colorEnum case .Red: 0xFF0000, .Green: 0x00FF00, .Blue: 0x0000FF, default: 0xFFFFFF)  
```

One nice thing about this is that it follows the existing switch statement syntax, thus putting "case" in front of each is not necessary but can be done if desired. 

To make the difference between expressions and statements clear, statements will continue to require braces after the conditional if present, and expressions will not have braces. 

All expressions must match the result type and for type inference, expressions must be the same result type. If you want something else it will not automatically find a more generic type, for example this would generate an error: 

``` swift
  let result = switch value 
      case      1: "String", 
                2: 52, 
      default:  nil
```

will not automatically create an Any? for "result". They must specify the more generic type on the left hand side. 

``` swift
  let result : Any? = switch value 
      case      1: "String", 
                2: 52, 
      default:  nil
```

## Detailed design

### Grammar:

``` swift
  result = switch pattern case label1: expression1, label2: expression2, ... labelN: expressionN, default: expressionD  
```

A switch expression allows certain different expressions to be executed depending on the value of a control expression.

A switch expression has the following form:

```
 switch control-expression 
    case pattern 1: expression1, 
           pattern 2 where condition: expression,
    case  pattern 3 where condition: expression,
           pattern 4 where condition: expression,
    default:
           expression
```

Only newly defined grammars are presented here. See Swift switch statement grammar for the existing grammars: 

```
switch-expression â†’ switch expression switch-expression-cases

switch-expression-cases switch-expression-case switch-expression-cases

switch-expression-case case-label expression | default-label expression
```

"switch" expression results must be a compatible type of the result. 

### Pattern Matching for "switch": 

All the current pattern matching abilities of switch statments should be present for example. "where" clauses. 

## Impact on existing code

Since this is a new capability and nothing else is being changed there should be no impact on existing code.  

## Alternatives considered

### Why not extend existing statements to be usable as expressions?

In a statement block it is common to not have return values. So you could make it an expression if the return value is used. This makes it more complex from both the programming model and the compiler perspective. 

Another problem is the proliferation of braces, expressions should be light, it looks cumbersome to have braces all through your expressions. It does not look as clean having braces in an expression as braces are usually used to group blocks of staements. Further it will help express the difference between an expression and a statement to only use braces for statements. For example all the extra braces in this case are harder to read:

``` swift
let color = switch enumColor {
  case .Red: (switch shade {case .DarkRed: 0xFFEEEE
                            case .LightRed:0xFF0000
                            default: 0xFF1010 } )
  default: 0xFFFFFF
}
```

note that the commas for each case are not necessary with this example but does look significanly more like Lisp :-)

If you look at the language grammar there is a clear separation between what is an expression vs a statement. It would be too large a change to try to unifiy expressions and statements. See thread for examples. 

Finally switch statements can have multiple statements after them, that is not the case for expressions, only one sub-expression can be in each part of the case. There is ambiguity as to the return value if this was a statement: 


``` swift
let color = switch enumColor {
  case .Red: (switch shade {case .Dark: func1() 
                                  x = 15 
                                  40 
                            case .Light: func3() 
                                  13
                                  x = 10
                            default: func2()
                            } )
  default: 0xFFFFFF
}
```

If changing statements into expressions is what is decided, then this seems like a far bigger change and beyond the scope of this proposal and this proposal should be declined. This proposal is likely far more straightforward to add to the existing language than making statements into expressions. 

### Add a new keyword "cases"?

you could make a "cases" keyword that is interchangeable with "case" to help readablity: 

``` swift
  int result = switch colorEnum { 
    cases      .Red: 0xFF0000,
               .Green: 0x00FF00,
               .Blue: 0x0000FF,
    default:   0xFFFFFF
  }
```
best not to add new keywords unless necessary, if people think this would help readablity, it should be an easy addtion. Would probably also want to support in statements. 
